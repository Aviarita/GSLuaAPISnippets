{
  "GlobalRealtime": {
    "prefix": "globals.realtime",
    "body": "globals.realtime()",
    "description": "Returns the local time in seconds."
  },
  "GlobalCurtime": {
    "prefix": "globals.curtime",
    "body": "globals.curtime()",
    "description": "Returns the game time in seconds. This number is synchronized with the server."
  },
  "GlobalFrametime": {
    "prefix": "globals.frametime",
    "body": "globals.frametime()",
    "description": "Returns the number of seconds elapsed during the last game frame."
  },
  "GlobalAbosluteFrametime": {
    "prefix": "globals.absoluteframetime",
    "body": "globals.absoluteframetime()",
    "description": "Returns the number of seconds elapsed during the last game frame."
  },
  "GlobalFramecount": {
    "prefix": "globals.framecount",
    "body": "globals.framecount()",
    "description": "Returns the number of frames since the game started."
  },
  "GlobalMaxPlayers": {
    "prefix": "globals.maxplayers",
    "body": "globals.maxplayers()",
    "description": "Returns the maximum number of players in the server."
  },
  "GlobalTickCount": {
    "prefix": "globals.tickcount",
    "body": "globals.tickcount()",
    "description": "Returns the number of ticks elapsed in the server."
  },
  "GlobalTickInterval": {
    "prefix": "globals.tickinterval",
    "body": "globals.tickinterval()",
    "description": "Returns the time elapsed in one game tick in seconds."
  },
  "GlobalMapName": {
    "prefix": "globals.mapname",
    "body": "globals.mapname()",
    "description": "Returns the name of the loaded map, or nil if you are not in game."
  },
  "ClientSetEventCallback": {
    "prefix": "client.set_event_callback",
    "body": "client.set_event_callback(${1:event_name}, ${2:callback_function})",
    "description": "syntax: client.set_event_callback(event_name, callback)\nevent_name - Name of the event.\ncallback - Lua function to call when this event occurs.\nReturns nil, or an error string on failure."
  },
  "ClientLog": {
    "prefix": "client.log",
    "body": "client.log(${1:console_msg})",
    "description": "syntax: client.log(msg, ...)\nmsg - The message\n... - Optional args to concatenate with msg."
  },
  "ClientColorLog": {
    "prefix": "client.color_log",
    "body": "client.color_log(${1:red}, ${2:green}, ${3:blue}, ${4:console_msg})",
    "description": "syntax: client.color_log(red, green, blue, msg, ...)\nred - red (0-255)\nngreen - ngreen (0-255)\nblue - blue (0-255)\nmsg - The message\n... - Optional args to concatenate with msg."
  },
  "ClientExec": {
    "prefix": "client.exec",
    "body": "client.exec(${1:cmd})",
    "description": "syntax: client.exec(cmd, ...)\ncmd - The console command(s) to execute.\n... - Optional args to concatenate with cmd."
  },
  "ClientUserIDToEntIndex": {
    "prefix": "client.userid_to_entindex",
    "body": "client.userid_to_entindex(${1:userid})",
    "description": "syntax: client.userid_to_entindex(userid)\nuserid - This is given by some game events.\nReturns the entity index, or 0 on failure."
  },
  "ClientGetCvar": {
    "prefix": "client.get_cvar",
    "body": "client.get_cvar(${1:cvar_name})",
    "description": "syntax: client.get_cvar(cvar_name)\ncvar_name - The name of the console variable.\nReturns a string representing the current value of the convar, or nil on failure."
  },
  "ClientSetCvar": {
    "prefix": "client.set_cvar",
    "body": "client.set_cvar(${1:cvar_name}, ${2:value})",
    "description": "syntax: client.set_cvar(cvar_name, value)\ncvar_name - The name of the console variable.\nvalue - Value you want the cvar to be forced to."
  },
  "ClientRandomInt": {
    "prefix": "client.random_int",
    "body": "client.random_int(${1:min}, ${2:max})",
    "description": "syntax: client.random_int(minimum, maximum)\nminimum - Lowest possible result\nmaximum - Highest possible result\nReturns a random integer between minimum and maximum."
  },
  "ClientRandomFloat": {
    "prefix": "client.random_float",
    "body": "client.random_float(${1:min}, ${2:max})",
    "description": "syntax: client.random_float(minimum, maximum)\nminimum - Lowest possible result\nmaximum - Highest possible result\nReturns a random float between minimum and maximum."
  },
  "ClientDrawDebugText": {
    "prefix": "client.draw_debug_text",
    "body": "client.draw_debug_text(${1:x}, ${2:y}, ${3:z}, ${4:line_offset}, ${5:duration}, ${6:r}, ${7:g}, ${8:b}, ${9:a}, ${10:...})",
    "description": "syntax: client.draw_debug_text(x, y, z, line_offset, duration, r, g, b, a, ...)\nx - Position in world space\ny - Position in world space\nz - Position in world space\nline_offset - Used for vertical alignment, use 0 for the first line.\nduration - Time in seconds that the text will remain on the screen.\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\n... - The text that will be drawn"
  },
  "ClientDrawHitboxes": {
    "prefix": "client.draw_hitboxes",
    "body": "client.draw_hitboxes(${1:entindex}, ${2:duration}, ${3:hitboxes}, ${4:line_offset}, ${5:duration}, ${6:r}, ${7:g}, ${8:b})",
    "description": "syntax: client.draw_hitboxes(entindex, duration, hitboxes, line_offset, duration, r, g, b)\nentindex - Entity index\nduration - Time in seconds\nhitboxes - Either the hitbox index, an array of hitbox indices, or 19 for all hitboxes\nline_offset - Used for vertical alignment, use 0 for the first line\nduration - Time in seconds that the text will remain on the screen\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)"
  },
  "ClientDrawText": {
    "prefix": "client.draw_text",
    "body": "client.draw_text(${1:paint_ctx}, ${2:x}, ${3:y}, ${4:r}, ${5:g}, ${6:b}, ${7:a}, ${8:flags}, ${9:max_width}, ${10:...}, ...)",
    "description": "syntax: client.draw_text(paint_ctx, x, y, r, g, b, a, flags, max_width, ..., ...)\npaint_ctx - The context passed to your 'paint' event callback\nx - Screen coordinate\ny - Screen coordinate\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\nflags - \"+\" for large text, \"-\" for small text, \"c\" for centered text. \"c\" can be combined with other flags. \"nil\" can be used for normal sized uncentered text\nmax_width - Text will be clipped if it exceeds this width in pixels\n... - Text that will be drawn\n... - Optional"
  },
  "ClientDrawRectangle": {
    "prefix": "client.draw_rectangle",
    "body": "client.draw_rectangle(${1:paint_ctx}, ${2:x}, ${3:y}, ${4:w}, ${5:h}, ${6:r}, ${7:g}, ${8:b}, ${9:a})",
    "description": "syntax: client.draw_rectangle(paint_ctx, x, y, w, h, r, g, b, a)\npaint_ctx - The context passed to your 'paint' event callback\nx - Screen coordinate\ny - Screen coordinate\nw - Width in pixels\nh - Height in pixels\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)"
  },
  "ClientDrawLine": {
    "prefix": "client.draw_line",
    "body": "client.draw_line(${1:paint_ctx}, ${2:xa}, ${3:ya}, ${4:xb}, ${5:yb}, ${6:r}, ${7:g}, ${8:b}, ${9:a})",
    "description": "syntax: client.draw_line(paint_ctx, xa, ya, xb, yb, r, g, b, a)\npaint_ctx - The context passed to your 'paint' event callback\nxa - Screen coordinate of point A\nya - Screen coordinate of point A\nxb - Screen coordinate of point B\nyb - Screen coordinate of point B\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)"
  },
  "ClientDrawGradient": {
    "prefix": "client.draw_gradient",
    "body": "client.draw_gradient(${1:paint_ctx}, ${2:x}, ${3:y}, ${4:w}, ${5:h}, ${6:r1}, ${7:g1}, ${8:b1}, ${9:a1}, ${10:r2}, ${11:g2}, ${12:b2}, ${13:a2}, ${14:ltr})",
    "description": "syntax: client.draw_gradient(paint_ctx, x, y, w, h, r1, g1, b1, a1, r2, g2, b2, a2, ltr)\npaint_ctx - The context passed to your paint event callback\nx - Screen coordinate\ny - Screen coordinate\nw - Width in pixels\nh - Height in pixels\nr1 - Red (1-255)\ng1 - Green (1-255)\nb1 - Blue (1-255)\na1 - Alpha (1-255)\nr2 - Red (1-255)\ng2 - Green (1-255)\nb2 - Blue (1-255)\na2 - Alpha (1-255)\nltr - Left to right. Pass true for horizontal gradient, or false for vertical."
  },
  "ClientDrawCircle": {
    "prefix": "client.draw_circle",
    "body": "client.draw_circle(${1:paint_ctx}, ${2:x}, ${3:y}, ${4:r}, ${5:g}, ${6:b}, ${7:a}, ${8:radius}, ${9:start_degrees}, ${10:percentage})",
    "description": "syntax: client.draw_circle(paint_ctx, x, y, r, g, b, a, radius, start_degrees, percentage)\npaint_ctx - The context passed to your paint event callback\nx - Screen coordinate\ny - Screen coordinate\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\nradius - Radius of the circle in pixels.\nstart_degrees - 0 is the right side, 90 is the bottom, 180 is the left, 270 is the top.\npercentage - Must be within [0.0-1.0]. 1.0 is a full circle, 0.5 is a half circle, etc."
  },
  "ClientDrawCircleOutline": {
    "prefix": "client.draw_circle_outline",
    "body": "client.draw_circle_outline(${1:paint_ctx}, ${2:x}, ${3:y}, ${4:r}, ${5:g}, ${6:b}, ${7:a}, ${8:radius}, ${9:start_degrees}, ${10:percentage}, ${11:thickness})",
    "description": "syntax: client.draw_circle_outline(paint_ctx, x, y, r, g, b, a, radius, start_degrees, percentage, thickness)\npaint_ctx - The context passed to your paint event callback\nx - Screen coordinate\ny - Screen coordinate\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\nradius - Radius of the circle in pixels.\nstart_degrees - 0 is the right side, 90 is the bottom, 180 is the left, 270 is the top.\npercentage - Must be within [0.0-1.0]. 1.0 is a full circle, 0.5 is a half circle, etc.\nthickness - Thickness of the outline in pixels."
  },
  "ClientDrawIndicator": {
    "prefix": "client.draw_indicator",
    "body": "client.draw_indicator(${1:paint_ctx}, ${2:r}, ${3:g}, ${4:b}, ${5:a}, ${6:...})",
    "description": "syntax: client.draw_indicator(paint_ctx, r, g, b, a, ...)     \npaint_ctx - The context passed to your 'paint' event callback\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\n... - Text that will be drawn."
  },
  "ClientWorldToScreen": {
    "prefix": "client.world_to_screen",
    "body": "client.world_to_screen(${1:paint_ctx}, ${2:x}, ${3:y}, ${4:z})",
    "description": "syntax: client.world_to_screen(paint_ctx, x, y, z)\npaint_ctx - The context passed to your 'paint' event callback\nx - Position in world space\ny - Position in world space\nz - Position in world space\nReturns screen coordinates (x, y), or nil if the world position is not visible on your screen."
  },
  "ClientScreenSize": {
    "prefix": "client.screen_size",
    "body": "client.screen_size()",
    "description": "syntax: client.screen_size()\nReturns (width, height)."
  },
  "ClientCameraAngles": {
    "prefix": "client.camera_angles",
    "body": "client.camera_angles()",
    "description": "syntax: client.camera_angles()\nReturns pitch, yaw, roll of where you are looking."
  },
  "ClientEyePosition": {
    "prefix": "client.eye_position",
    "body": "client.eye_position()",
    "description": "syntax: client.eye_position()\nReturns x, y, z world coordinates of the local player's eye position, or nil on failure."
  },
  "ClientVisible": {
    "prefix": "client.visible",
    "body": "client.visible(${1:x}, ${2:y}, ${3:z})",
    "description": "syntax: client.visible(x, y, z)\nx - Position in world space\ny - Position in world space\nz - Position in world space\nReturns true if the position is visible. For example, you could use a player's origin to see if they are visible."
  },
  "ClientTraceLine": {
    "prefix": "client.trace_line",
    "body": "client.trace_line(${1:skip_entindex}, ${2:from_x}, ${3:from_y}, ${4:from_z}, ${5:to_x}, ${6:to_y}, ${7:to_z})",
    "description": "syntax: client.trace_line(skip_entindex, from_x, from_y, from_z, to_x, to_y, to_z)\nskip_entindex - Ignore this entity while tracing\nfrom_x - Position in world space\nfrom_y - Position in world space\nfrom_z - Position in world space\nto_x - Position in world space\nto_y - Position in world space\nto_z - Position in world space."
  },
  "ClientDelayCall": {
    "prefix": "client.delay_call",
    "body": "client.delay_call(${1:delay}, ${2:callback}, ${3:...})",
    "description": "syntax: client.delay_call(delay, callback, ...)\ndelay - Time in seconds to wait before calling callback.\ncallback - The lua function that will be called after delay seconds.\n... - Optional arguments that will be passed to the callback."
  },
  "ClientSetClanTag": {
    "prefix": "client.set_clan_tag",
    "body": "client.set_clan_tag(${1:string})",
    "description": "syntax: client.set_clan_tag(string).\nstring - A string you want to use as your clantag."
  },
  "UINewCheckbox": {
    "prefix": "ui.new_checkbox",
    "body": "ui.new_checkbox(${1:tab}, ${2:container}, ${3:name})",
    "description": "syntax: ui.new_checkbox(tab, container, name)\ntab - The name of the tab: AA, RAGE, LEGIT, MISC, PLAYERS, SKINS, or VIS.\ncontainer - The name of the existing container to which this checkbox will be added.\nname - The name of the checkbox.\nReturns a special variable that can be passed to 'ui.get' and 'ui.set', or nil on failure."
  },
  "UINewSlider": {
    "prefix": "ui.new_slider",
    "body": "ui.new_slider(${1:tab}, ${2:container}, ${3:name}, ${4:min}, ${5:max})",
    "description": "syntax: ui.new_slider(tab, container, name, min, max)\ntab - The name of the tab: AA, RAGE, LEGIT, MISC, PLAYERS, SKINS, or VIS.\ncontainer - The name of the existing container to which this checkbox will be added.\nname - The name of the slider.\nmin - The minimum value that can be set using the slider.\nmax - The maximum value that can be set using the slider.\nReturns a special variable that can be passed to 'ui.get' and 'ui.set', or nil on failure."
  },
  "UINewButton": {
    "prefix": "ui.new_button",
    "body": "ui.new_button(${1:tab}, ${2:container}, ${3:name}, ${4:callback})",
    "description": "syntax: ui.new_button(tab, container, name, callback)\ntab - The name of the tab: AA, RAGE, LEGIT, MISC, PLAYERS, SKINS, or VIS.\ncontainer - The name of the existing container to which this checkbox will be added.\nname - The name of the button.\ncallback - The lua function that will be called when the button is pressed.\nReturns nil on failure."
  },
  "UINewColorPicker": {
    "prefix": "ui.new_color_picker",
    "body": "ui.new_color_picker(${1:tab}, ${2:container}, ${3:name}, ${4:red}, ${5:green}, ${6:blue}, ${7:alpha})",
    "description": "syntax: ui.new_color_picker(tab, container, name, red, green, blue, alpha)\ntab - The name of the tab: AA, RAGE, LEGIT, MISC, PLAYERS, SKINS, or VIS.\ncontainer - The name of the existing container to which this checkbox will be added.\nname - The name of the button.\nr - Optional initial red value (0-255) \ng - Optional initial green value (0-255) \nb - Optional initial blue value (0-255) \na - Optional initial alpha value (0-255)."
  },
  "UINewHotkey": {
    "prefix": "ui.new_hotkey",
    "body": "ui.new_hotkey(${1:tab}, ${2:container}, ${3:name})",
    "description": "syntax: ui.new_hotkey(tab, container, name)\ntab - The name of the tab: AA, RAGE, LEGIT, MISC, PLAYERS, SKINS, or VISUALS.\ncontainer - The name of the existing container to which this control will be added.\nname - The name of the hotkey.\nReturns a special value that can be passed to ui.get to see if the hotkey is pressed, or throws an error on failure."
  },
  "UINewCombobox": {
    "prefix": "ui.new_combobox",
    "body": "ui.new_combobox(${1:tab}, ${2:container}, ${3:name}, ${4:...})",
    "description": "syntax: ui.new_combobox(tab, container, name)\ntab - The name of the tab: AA, RAGE, LEGIT, MISC, PLAYERS, SKINS, or VISUALS.\ncontainer - The name of the existing container to which this control will be added.\nname - The name of the combobox.\n... - One or more comma separated string values that will be added to the combobox. Alternatively, a table of strings that will be added.\nReturns a special value that can be passed to ui.get and ui.set, or throws an error on failure."
  },
  "UINewMultiselect": {
    "prefix": "ui.new_multiselect",
    "body": "ui.new_multiselect(${1:tab}, ${2:container}, ${3:name}, ${4:...})",
    "description": "syntax: ui.new_multiselect(tab, container, name)\ntab - The name of the tab: AA, RAGE, LEGIT, MISC, PLAYERS, SKINS, or VISUALS.\ncontainer - The name of the existing container to which this control will be added.\nname - The name of the multiselect.\n... - One or more comma separated string values that will be added to the combobox. Alternatively, a table of strings that will be added.\nReturns a special value that can be passed to ui.get and ui.set, or throws an error on failure."
  },
  "UISet": {
    "prefix": "ui.set",
    "body": "ui.set(${1:name}, ${2:value})",
    "description": "syntax: ui.set(item, value)\nitem - The result of either new_checkbox or new_slider.\nvalue - true or false for a checkbox, or an integer for a slider. Do not pass an integer that is outside of a slider's minimum/maximum value."
  },
  "UIGet": {
    "prefix": "ui.get",
    "body": "ui.get(${1:item})",
    "description": "syntax: ui.get(item)\nitem - The result of either new_checkbox or new_slider.\nReturns true or false for a checkbox, or an integer for a slider."
  },
  "UIReference": {
    "prefix": "ui.reference",
    "body": "ui.reference(${1:tab}, ${2:container}, ${3:name})",
    "description": "syntax: ui.reference(tab, container, name)\ntab - The name of the tab: AA, RAGE, LEGIT, MISC, PLAYERS, SKINS, or VISUALS.\ncontainer - The name of the existing container to which this checkbox will be added.\nname - The name of the menu item.\nAvoid calling this from inside a function. Returns a reference that can be passed to ui.get and ui.set, or throws an error on failure. This allows you to access a built-in pre-existing menu items. This function returns multiple values when the specified menu item is followed by unnamed menu items, for example a color picker or a hotkey."
  },
  "UIIsMenuOpen": {
    "prefix": "ui.is_menu_open",
    "body": "ui.is_menu_open()",
    "description": "syntax: ui.is_menu_open()\nReturns true if the menu is currently open."
  },
  "UISetCallback": {
    "prefix": "ui.set_callback",
    "body": "ui.set_callback(${1:name}, ${2:callback})",
    "description": "syntax: ui.set_callback(item, callback)\nitem - The special value returned by ui.new_*. Do not try passing a reference to an existing menu item.\ncallback - Lua function that will be called when the menu item changes values. For example, this will be called when the user checks or unchecks a checkbox."
  },
  "UISetVisible": {
    "prefix": "ui.set_visible",
    "body": "ui.set_visible(${1:name}, ${2:visible})",
    "description": "syntax: ui.set_visible(item, visible)  \nitem - A menu item reference.\nvisible - Boolean. Pass false to hide the control from the menu."
  },
  "EntityGetLocalPlayer": {
    "prefix": "entity.get_local_player",
    "body": "entity.get_local_player()",
    "description": "syntax: entity.get_local_player()\nReturns the entity index for the local player, or nil on failure."
  },
  "EntityGetAll": {
    "prefix": "entity.get_all",
    "body": "entity.get_all(${1:classname})",
    "description": "syntax: entity.get_all(classname)\nclassname - Optional. If provided, only entities of this type are added to the list.\nReturns an array of entity indices, or nil on failure."
  },
  "EntityGetPlayers": {
    "prefix": "entity.get_players",
    "body": "entity.get_players(${1:enemies_only})",
    "description": "syntax: entity.get_players(enemies_only)\nenemies_only - Optional. If provided, you and the players on your team will not be added to the list.\nReturns an array of player entity indices, or nil on failure."
  },
  "EntityGetClassName": {
    "prefix": "entity.get_classname",
    "body": "entity.get_classname(${1:ent})",
    "description": "syntax: entity.get_classname(ent)\nent - Entity index.\nReturns the name of the entity's class, or nil on failure."
  },
  "EntitySetProp": {
    "prefix": "entity.set_prop",
    "body": "entity.set_prop(${1:ent}, ${2:propname}, ${3:value})",
    "description": "syntax: entity.set_prop(ent, propname, value)\nent - Entity index.\npropname - Name of the networked property.\nvalue - The property will be set to this value. For vectors or angles, separate the components by commas."
  },
  "EntityGetProp": {
    "prefix": "entity.get_prop",
    "body": "entity.get_prop(${1:ent}, ${2:propname}",
    "description": "syntax: entity.get_prop(ent, propname)\nent - Entity index.\npropname - Name of the networked property.\nReturns the value of the property, or nil on failure."
  },
  "EntityIsEnemy": {
    "prefix": "entity.is_enemy",
    "body": "entity.is_enemy(${1:ent})",
    "description": "syntax: entity.is_enemy(ent)\nent - Entity index.\nReturns true if the entity is on the other team."
  },
  "EntityIsAlive": {
    "prefix": "entity.is_alive",
    "body": "entity.is_alive(${1:ent})",
    "description": "syntax: entity.is_alive(ent)\nent - Entity index.\nReturns true if the entity is alive."
  },
 "EntityIsDormat": {
    "prefix": "entity.is_dormant",
    "body": "entity.is_dormant(${1:ent})",
    "description": "syntax: entity.is_dormant(ent)\nent - Entity index.\nReturns true if the entity is dormant."
  },
  "EntityGetPlayerName": {
    "prefix": "entity.get_player_name",
    "body": "entity.get_player_name(${1:ent})",
    "description": "syntax: entity.get_player_name(ent)\nent - Entity index.\nReturns the player's name, or nil on failure."
  },
  "EntityGetPlayerWeapon": {
    "prefix": "entity.get_player_weapon",
    "body": "entity.get_player_weapon(${1:ent})",
    "description": "syntax: entity.get_player_weapon(ent)\nent - Entity index.\nReturns the entity index of the player's active weapon, or nil if the player is not alive, dormant, etc."
  },
   "EntityHitboxPosition": {
    "prefix": "entity.hitbox_position",
    "body": "entity.hitbox_position(${1:player}, ${2:hitbox})",
    "description": "syntax: entity.hitbox_position(player)\nplayer - Entity index of the player.\nhitbox - Either a string of the hitbox name, or an integer index of the hitbox.\nReturns world coordinates x, y, z, or nil on failure."
  },
  "EntityGetSteam64": {
    "prefix": "entity.get_steam64",
    "body": "entity.get_steam64(${1:player})",
    "description": "syntax: entity.get_steam64(player)\nplayer - Entity index of the player.\nReturns 64 bit steam ID, or nil on failure."
  },
  "EntityGetBoundingBox": {
    "prefix": "entity.get_bounding_box",
    "body": "entity.get_bounding_box(${1:paint_ctx}, ${2:ent})",
    "description": "syntax: entity.get_bounding_box(paint_ctx, ent)\npaint_ctx - The context passed to your paint event callback\nent - Entity index.\nReturns a table with topX, topY, botX, botY and alpha(float 0.0 - 1.0)."
  },
  "RendererDrawText": {
    "prefix": "renderer.text",
    "body": "renderer.text(${1:x}, ${2:y}, ${3:r}, ${4:g}, ${5:b}, ${6:a}, ${7:flags}, ${8:max_width}, ${9:...})",
    "description": "syntax: renderer.text(x, y, r, g, b, a, flags, max_width, ...)\npaint_ctx - The context passed to your 'paint' event callback\nx - Screen coordinate\ny - Screen coordinate\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\nflags - \"+\" for large text, \"-\" for small text, \"c\" for centered text. \"c\" can be combined with other flags. \"nil\" can be used for normal sized uncentered text\nmax_width - Text will be clipped if it exceeds this width in pixels\n... - Text that will be drawn\n... - Optional"
  },
  "RendererDrawRectangle": {
    "prefix": "renderer.rectangle",
    "body": "renderer.rectangle(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:r}, ${6:g}, ${7:b}, ${8:a})",
    "description": "syntax: renderer.rectangle(x, y, w, h, r, g, b, a)\npaint_ctx - The context passed to your 'paint' event callback\nx - Screen coordinate\ny - Screen coordinate\nw - Width in pixels\nh - Height in pixels\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)"
  },
  "RendererDrawLine": {
    "prefix": "renderer.line",
    "body": "renderer.line(${1:xa}, ${2:ya}, ${3:xb}, ${4:yb}, ${5:r}, ${6:g}, ${7:b}, ${8:a})",
    "description": "syntax: renderer.line(xa, ya, xb, yb, r, g, b, a)\npaint_ctx - The context passed to your 'paint' event callback\nxa - Screen coordinate of point A\nya - Screen coordinate of point A\nxb - Screen coordinate of point B\nyb - Screen coordinate of point B\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)"
  },
  "RendererDrawGradient": {
    "prefix": "renderer.gradient",
    "body": "renderer.gradient(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:r1}, ${6:g1}, ${7:b1}, ${8:a1}, ${9:r2}, ${10:g2}, ${11:b2}, ${12:a2}, ${13:ltr})",
    "description": "syntax: renderer.gradient(x, y, w, h, r1, g1, b1, a1, r2, g2, b2, a2, ltr)\npaint_ctx - The context passed to your paint event callback\nx - Screen coordinate\ny - Screen coordinate\nw - Width in pixels\nh - Height in pixels\nr1 - Red (1-255)\ng1 - Green (1-255)\nb1 - Blue (1-255)\na1 - Alpha (1-255)\nr2 - Red (1-255)\ng2 - Green (1-255)\nb2 - Blue (1-255)\na2 - Alpha (1-255)\nltr - Left to right. Pass true for horizontal gradient, or false for vertical."
  },
  "RendererDrawCircle": {
    "prefix": "renderer.circle",
    "body": "renderer.circle(${1:x}, ${2:y}, ${3:r}, ${4:g}, ${5:b}, ${6:a}, ${7:radius}, ${8:start_degrees}, ${9:percentage})",
    "description": "syntax: renderer.circle(x, y, r, g, b, a, radius, start_degrees, percentage)\npaint_ctx - The context passed to your paint event callback\nx - Screen coordinate\ny - Screen coordinate\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\nradius - Radius of the circle in pixels.\nstart_degrees - 0 is the right side, 90 is the bottom, 180 is the left, 270 is the top.\npercentage - Must be within [0.0-1.0]. 1.0 is a full circle, 0.5 is a half circle, etc."
  },
  "RendererDrawCircleOutline": {
    "prefix": "renderer.circle_outline",
    "body": "renderer.circle_outline(${1:x}, ${2:y}, ${3:r}, ${4:g}, ${5:b}, ${6:a}, ${7:radius}, ${8:start_degrees}, ${9:percentage}, ${10:thickness})",
    "description": "syntax: renderer.circle_outline(x, y, r, g, b, a, radius, start_degrees, percentage, thickness)\npaint_ctx - The context passed to your paint event callback\nx - Screen coordinate\ny - Screen coordinate\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\nradius - Radius of the circle in pixels.\nstart_degrees - 0 is the right side, 90 is the bottom, 180 is the left, 270 is the top.\npercentage - Must be within [0.0-1.0]. 1.0 is a full circle, 0.5 is a half circle, etc.\nthickness - Thickness of the outline in pixels."
  },
  "RendererDrawIndicator": {
    "prefix": "renderer.indicator",
    "body": "renderer.indicator(${1:r}, ${2:g}, ${3:b}, ${4:a}, ${5:...})",
    "description": "syntax: renderer.indicator(r, g, b, a, ...)     \npaint_ctx - The context passed to your 'paint' event callback\nr - Red (1-255)\ng - Green (1-255)\nb - Blue (1-255)\na - Alpha (1-255)\n... - Text that will be drawn."
  },
  "RendererWorldToScreen": {
    "prefix": "renderer.world_to_screen",
    "body": "renderer.world_to_screen(${1:x}, ${2:y}, ${3:z})",
    "description": "syntax: renderer.world_to_screen(x, y, z)\npaint_ctx - The context passed to your 'paint' event callback\nx - Position in world space\ny - Position in world space\nz - Position in world space\nReturns screen coordinates (x, y), or nil if the world position is not visible on your screen."
  },
}
